<?xml version="1.0"?>
<SyntaxDefinition name="Cottle" xmlns="http://icsharpcode.net/sharpdevelop/syntaxdefinition/2008">
  <!-- A definition for the Cottle text template engine documented at <https://r3c.github.io/cottle/> and available at <https://www.nuget.org/packages/Cottle/> -->

  <!-- AvalonEdit documentation: 
  <http://avalonedit.net/documentation/> 
  <https://www.codeproject.com/Articles/42490/Using-AvalonEdit-WPF-Text-Editor?msg=4879049#xx4879049xx> 
  -->
  
  <Color name="Body text" foreground="DarkSlateGray"/>
  <Color name="Comment" foreground="Green" fontStyle="italic"/>
  <Color name="Code" foreground="Purple"/>
  <Color name="Delimiter" foreground="Purple" fontWeight="bold"/>
  <Color name="EscapeDelimiter" foreground="Orchid"/>
  <Color name="Keyword" foreground="MediumVioletRed"/>
  <Color name="Quote mark" foreground="Blue"/>
  <Color name="Operator" foreground="Blue"/>
  <Color name="Literals" foreground="Blue"/>
  <Color name="Built-in functions" foreground="MediumOrchid" fontWeight="bold"/>
  <Color name="Custom functions" foreground="DodgerBlue"/>
  <Color name="Custom properties" foreground="LightSeaGreen"/>

  <!-- The main rule set: it states that Cottle docs always begin as body text. -->
  <RuleSet>
    <Import ruleSet="Body text"/>
  </RuleSet>

  <!-- The Body text rule set: it is referenced recursively and can contain only code and comment spans.-->
  <RuleSet name="Body text">
    <Import ruleSet="Escape sequences"/>

    <!-- comments -->
    <Span color="Comment" multiline="true" begin="{_" end="}" ruleSet="Comment"/>

    <!-- code -->
    <Span color="Code" fontFamily="Consolas" multiline="true" ruleSet="Code">
      <Begin color="Delimiter">{</Begin>
      <End color="Delimiter">}</End>
    </Span>
  </RuleSet>

  <!-- The Comment rule set simply caters for escape sequences. -->
  <RuleSet name="Comment">
    <Import ruleSet="Escape sequences"/>
  </RuleSet>

  <!-- The Predicate statement rule set is used in statements such as `if` and `elif`.
  It says that we start with code (the predicate) until the first unescaped colon, and everything after that is recursive body text. -->
  <RuleSet name="Predicate statement">
    <Import ruleSet="Code"/>
    <Span ruleSet="Body text" color="Body text" multiline="true">
      <Begin color="Delimiter">:</Begin>
      <End color="Delimiter">(?=[|}])</End>
    </Span>
  </RuleSet>

    <!-- The Code rule set. It can contain code, literals, comments and keywords. Certain keywords can recurse us back to a body text span. -->
  <RuleSet name="Code">
    <Import ruleSet="Escape sequences"/>
    <Import ruleSet="Literals"/>
    <Import ruleSet="Built-in keywords"/>
    <Import ruleSet="Built-in operators"/>
    <Import ruleSet="Built-in functions"/>
    <Import ruleSet="Custom functions"/>
    <Import ruleSet="Custom properties"/>

    <!-- comments -->
    <Span color="Comment" multiline="true" begin="{_" end="}" ruleSet="Comment"/>

    <!-- delimiters -->
    <Rule color="Delimiter">
      [{|:}]
    </Rule>

    <!-- String literals are treated as body text -->
    <Span color="Body text" ruleSet="Body text">
      <Begin color="Quote mark">"</Begin>
      <End color="Quote mark">"</End>
    </Span>

    <!-- Same for single-quoted strings -->
    <Span color="Body text" ruleSet="Body text">
      <Begin color="Quote mark">'</Begin>
      <End color="Quote mark">'</End>
    </Span>

    <!-- if -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">if</Begin>
      <End color="Delimiter">
        (
        (?!\|\|) ## do not end on a double pipe (logical or)
        ?=[|}] # end if we lookahead to a single pipe or close brace
        )
      </End>
    </Span>

    <!-- elif -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">elif</Begin>
      <End color="Delimiter">(?=[|}])</End>
    </Span>

    <!-- else -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">else</Begin>
      <End color="Delimiter">(?=})</End>
    </Span>

    <!-- for -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">for</Begin>
      <End color="Delimiter">(?=[|}])</End>
    </Span>

    <!-- empty -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">empty</Begin>
      <End color="Delimiter">(?=})</End>
    </Span>

    <!-- while -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">while</Begin>
      <End color="Delimiter">(?=})</End>
    </Span>
  </RuleSet>

  <!-- Backslash escape sequences are common enough to merit a rule set -->
  <RuleSet name="Escape sequences">
    <Span>
      <Begin color="EscapeDelimiter">\\</Begin>
      <End>.</End>
    </Span>
  </RuleSet>

  <RuleSet name="Literals">
    <!-- Digits -->
    <Rule color="Literals">
      (    \d+(\.\d+)?   # number with optional floating point
      |    \.\d+         # or just starting with floating point
      )
    </Rule>

    <!-- String literals are treated as body text -->

    <!-- Other literals-->
    <Keywords color="Literals">
      <Word>true</Word>
      <Word>false</Word>
      <Word>void</Word>
    </Keywords>
  </RuleSet>

  <RuleSet name="Built-in keywords">
    <Keywords color="Keyword">
      <Word>if</Word>
      <Word>elif</Word>
      <Word>else</Word>
      <Word>for</Word>
      <Word>while</Word>
      <Word>empty</Word>
      <Word>in</Word>
      <Word>set</Word>
      <Word>to</Word>
      <Word>is</Word>
      <Word>echo</Word>
      <Word>dump</Word>
      <Word>and</Word>
      <Word>or</Word>
      <Word>not</Word>
      <Word>return</Word>
    </Keywords>
  </RuleSet>

  <RuleSet name="Built-in operators">
    <Keywords color="Operator">
      <Word>(</Word>
      <Word>)</Word>
      <Word>[</Word>
      <Word>]</Word>
      <Word>,</Word>
      <Word>!</Word>
      <Word>+</Word>
      <Word>-</Word>
      <Word>*</Word>
      <Word>/</Word>
      <Word>%</Word>
      <Word>&amp;&amp;</Word>
      <Word>||</Word>
      <Word>&lt;</Word>
      <Word>&lt;=</Word>
      <Word>=</Word>
      <Word>!=</Word>
      <Word>&gt;=</Word>
      <Word>&gt;</Word>
    </Keywords>
  </RuleSet>

  <RuleSet name="Built-in functions">
    <Keywords color="Built-in functions">
      <Word>abs</Word>
      <Word>add</Word>
      <Word>call</Word>
      <Word>cast</Word>
      <Word>cat</Word>
      <Word>ceil</Word>
      <Word>char</Word>
      <Word>cmp</Word>
      <Word>cos</Word>
      <Word>cross</Word>
      <Word>default</Word>
      <Word>defined</Word>
      <Word>div</Word>
      <Word>eq</Word>
      <Word>except</Word>
      <Word>filter</Word>
      <Word>find</Word>
      <Word>flip</Word>
      <Word>floor</Word>
      <Word>format</Word>
      <Word>ge</Word>
      <Word>gt</Word>
      <Word>has</Word>
      <Word>join</Word>
      <Word>lcase</Word>
      <Word>le</Word>
      <Word>len</Word>
      <Word>lt</Word>
      <Word>map</Word>
      <Word>match</Word>
      <Word>max</Word>
      <Word>min</Word>
      <Word>mod</Word>
      <Word>mul</Word>
      <Word>ne</Word>
      <Word>ord</Word>
      <Word>pow</Word>
      <Word>rand</Word>
      <Word>range</Word>
      <Word>round</Word>
      <Word>sin</Word>
      <Word>slice</Word>
      <Word>sort</Word>
      <Word>split</Word>
      <Word>sub</Word>
      <Word>token</Word>
      <Word>type</Word>
      <Word>ucase</Word>
      <Word>union</Word>
      <Word>when</Word>
      <Word>xor</Word>
      <Word>zip</Word>
    </Keywords>
  </RuleSet>

  <RuleSet name="Custom functions">
    <Keywords color="Custom functions">
      <Word>SetState</Word>
      <Word>Humanise</Word>
      <Word>Occasionally</Word>
      <Word>OneOf</Word>
      <Word>P</Word>
      <Word>F</Word>
      <!-- etc... -->
    </Keywords>
  </RuleSet>

  <RuleSet name="Custom properties">
    <Keywords color="Custom properties">
      <Word>event</Word>
      <Word>rewards</Word>
      <Word>faction</Word>
      <Word>orbitalperiod</Word>
      <Word>stellarclass</Word>
      <!-- etc... -->
    </Keywords>
  </RuleSet>

</SyntaxDefinition>
