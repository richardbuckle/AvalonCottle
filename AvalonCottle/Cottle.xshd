<?xml version="1.0"?>
<SyntaxDefinition name="Cottle" xmlns="http://icsharpcode.net/sharpdevelop/syntaxdefinition/2008">
  <!-- A definition for the Cottle text template engine documented at <https://r3c.github.io/cottle/>-->

  <!-- AvalonEdit documentation: 
  <http://avalonedit.net/documentation/> 
  <https://www.codeproject.com/Articles/42490/Using-AvalonEdit-WPF-Text-Editor?msg=4879049#xx4879049xx> 
  -->
  
  <Color name="Body text" foreground="DarkSlateGray"/>
  <Color name="Comment" foreground="Green" fontStyle="italic"/>
  <Color name="Code" foreground="Purple"/>
  <Color name="Delimiter" foreground="Purple" fontWeight="bold"/>
  <Color name="Keyword" foreground="MediumVioletRed"/>
  <Color name="Quote mark" foreground="SlateBlue"/>
  <Color name="Operator" foreground="SlateBlue" fontWeight="bold"/>
  <Color name="Literals" foreground="Blue"/>
  <Color name="Built-in functions" foreground="MediumOrchid"/>
  <Color name="Custom functions" foreground="DodgerBlue"/>
  <Color name="Custom properties" foreground="LightSeaGreen"/>

  <!-- The main rule set simply references the "Body text" rule set, which is written separately for clarity. -->
  <RuleSet>
    <Import ruleSet="Body text"/>
  </RuleSet>

  <!-- The Body text rule set: it is referenced recursively and can contain only code and comment spans.-->
  <RuleSet name="Body text">
    <!-- escape sequences -->
    <Span begin="\\" end="."/>

    <!-- comments -->
    <Span color="Comment" multiline="true" begin="{_" end="}" ruleSet="Comment"/>

    <!-- code -->
    <Span color="Code" fontFamily="Consolas" multiline="true" ruleSet="Code">
      <Begin color="Delimiter">{</Begin>
      <End color="Delimiter">}</End>
    </Span>
  </RuleSet>

  <!-- The comment rule set simply caters for escape sequences. -->
  <RuleSet name="Comment">
    <!-- escape sequences -->
    <Span begin="\\" end="."/>
  </RuleSet>

  <!-- Used only within predicate statements such as if and elif.
  Everything up to the first colon is code, the remainder is body text -->
  <RuleSet name="Predicate statement">
    <Span ruleSet="Body text" color="Body text" multiline="true">
      <Begin color="Delimiter">:</Begin>
      <End color="Delimiter">(?=[|}])</End>
    </Span>
  </RuleSet>

  <!-- The code rule set. It can contain code, comments and keywords. Certain keywords can recurse us back to a body text span. -->
  <RuleSet name="Code">
    <!-- comments -->
    <Span color="Comment" multiline="true" begin="{_" end="}" ruleSet="Comment"/>

    <!-- delimiters -->
    <Rule color="Delimiter">
      [{|:}]
    </Rule>

    <!-- String literals are treated as body text -->
    <Span color="Body text" ruleSet="Body text">
      <Begin color="Quote mark">"</Begin>
      <End color="Quote mark">"</End>
    </Span>

    <!-- Same for single-quoted strings -->
    <Span color="Body text" ruleSet="Body text">
      <Begin color="Quote mark">'</Begin>
      <End color="Quote mark">'</End>
    </Span>

    <!-- if -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">if</Begin>
      <End color="Delimiter">(?=[|}])</End>
    </Span>

    <!-- elif -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">elif</Begin>
      <End color="Delimiter">(?=[|}])</End>
    </Span>

    <!-- else -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">else</Begin>
      <End color="Delimiter">(?=})</End>
    </Span>

    <!-- for -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">for</Begin>
      <End color="Delimiter">(?=[|}])</End>
    </Span>

    <!-- empty -->
    <Span ruleSet="Predicate statement" multiline="true">
      <Begin color="Keyword">empty</Begin>
      <End color="Delimiter">(?=})</End>
    </Span>

    <Keywords color="Keyword">
      <Word>if</Word>
      <Word>elif</Word>
      <Word>else</Word>
      <Word>for</Word>
      <Word>while</Word>
      <Word>empty</Word>
      <Word>in</Word>
      <Word>set</Word>
      <Word>to</Word>
      <Word>is</Word>
      <!-- etc... -->
    </Keywords>

    <Keywords color="Operator">
      <Word>(</Word>
      <Word>)</Word>
      <Word>[</Word>
      <Word>]</Word>
      <Word>,</Word>
      <Word>!</Word>
      <Word>+</Word>
      <Word>-</Word>
      <Word>*</Word>
      <Word>/</Word>
      <Word>%</Word>
      <Word>&amp;&amp;</Word>
      <Word>||</Word>
      <Word>&lt;</Word>
      <Word>&lt;=</Word>
      <Word>=</Word>
      <Word>!=</Word>
      <Word>&gt;=</Word>
      <Word>&gt;</Word>
    </Keywords>

    <!-- Digits -->
    <Rule color="Literals">
      (    \d+(\.\d+)?   #number with optional floating point
      |    \.\d+         #or just starting with floating point
      )
    </Rule>

    <!-- Other literals-->
    <Keywords color="Literals">
      <Word>true</Word>
      <Word>false</Word>
      <Word>void</Word>
    </Keywords>

    <Keywords color="Built-in functions">
      <Word>len</Word>
      <Word>max</Word>
      <Word>min</Word>
      <Word>cat</Word>
      <Word>dump</Word>
      <!-- etc... -->
    </Keywords>

    <Keywords color="Custom functions">
      <Word>SetState</Word>
      <Word>Humanise</Word>
      <Word>Occasionally</Word>
      <Word>OneOf</Word>
      <Word>P</Word>
      <!-- etc... -->
    </Keywords>

    <Keywords color="Custom properties">
      <Word>event</Word>
      <Word>rewards</Word>
      <Word>faction</Word>
      <Word>orbitalperiod</Word>
      <Word>stellarclass</Word>
      <!-- etc... -->
    </Keywords>
  </RuleSet>

</SyntaxDefinition>
